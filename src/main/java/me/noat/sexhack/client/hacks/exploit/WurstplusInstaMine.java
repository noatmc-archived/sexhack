package me.noat.sexhack.client.hacks.exploit;

import me.noat.sexhack.client.event.events.WurstplusEventDamageBlock;
import me.noat.sexhack.client.event.events.WurstplusEventPacket;
import me.noat.sexhack.client.guiscreen.settings.Setting;
import me.noat.sexhack.client.hacks.Module;
import me.noat.sexhack.client.hacks.WurstplusCategory;
import me.noat.sexhack.client.util.WurstplusTimer;
import me.zero.alpine.fork.listener.EventHandler;
import me.zero.alpine.fork.listener.Listener;
import net.minecraft.block.Block;
import net.minecraft.block.state.IBlockState;
import net.minecraft.init.Items;
import net.minecraft.network.Packet;
import net.minecraft.network.play.client.CPacketPlayerDigging;
import net.minecraft.util.EnumFacing;
import net.minecraft.util.EnumHand;
import net.minecraft.util.math.BlockPos;

/*
  Kami147 | Author
  noatmc | Port to Wurstplus Two
  17/06/2021 11:56 GMT+7
*/
public class WurstplusInstaMine extends Module {

    public static WurstplusInstaMine INSTANCE;
    Setting autoBreak = create("Auto Break", "IMAutoBreak", true);
    Setting delay = create("Delay", "IMDelay", 20, 0, 500);
    Setting picOnly = create("Only Pickaxe", "IMOnlyPickaxe", true);
    Setting r = create("R", "InstantMineR", 255, 0, 255);
    Setting g = create("G", "InstantMineG", 255, 0, 255);
    Setting b = create("B", "InstantMineB", 255, 0, 255);
    Setting a = create("A", "InstantMineA", 100, 0, 255);
    private BlockPos renderBlock;
    private BlockPos lastBlock;
    private boolean packetCancel = false;
    private final WurstplusTimer breaktimer = new WurstplusTimer();
    private EnumFacing direction;
    @EventHandler
    private final Listener<WurstplusEventPacket.SendPacket> packetSendListener = new Listener<>(event -> {
        Packet packet = event.getPacket();
        if (packet instanceof CPacketPlayerDigging) {
            CPacketPlayerDigging digPacket = (CPacketPlayerDigging) packet;
            if (((CPacketPlayerDigging) packet).getAction() == CPacketPlayerDigging.Action.START_DESTROY_BLOCK && packetCancel)
                event.cancel();
        }
    });
    @EventHandler
    private final Listener<WurstplusEventDamageBlock> OnDamageBlock = new Listener<>(p_Event -> {
        if (canBreak(p_Event.getPos())) {

            if (lastBlock == null || p_Event.getPos().getX() != lastBlock.getX() || p_Event.getPos().getY() != lastBlock.getY() || p_Event.getPos().getZ() != lastBlock.getZ()) {
                //Command.sendChatMessage("New Block");
                packetCancel = false;
                //Command.sendChatMessage(p_Event.getPos()+" : "+lastBlock);
                mc.player.swingArm(EnumHand.MAIN_HAND);
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK,
                        p_Event.getPos(), p_Event.getDirection()));
                packetCancel = true;
            } else {
                packetCancel = true;
            }
            //Command.sendChatMessage("Breaking");
            mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                    p_Event.getPos(), p_Event.getDirection()));

            renderBlock = p_Event.getPos();
            lastBlock = p_Event.getPos();
            direction = p_Event.getDirection();

            p_Event.cancel();

        }
    });

    public WurstplusInstaMine() {
        super(WurstplusCategory.WURSTPLUS_EXPLOIT);

        this.name = "Instant Mine";
        this.tag = "InstaMine";
        this.description = "block game exploit";
    }

    public static WurstplusInstaMine getInstance() {
        if (INSTANCE == null) {
            INSTANCE = new WurstplusInstaMine();
        }
        return INSTANCE;
    }

    public void onEnable() {
        INSTANCE = this;
    }

    @Override
    public void update() {
        if (renderBlock != null) {
            if (autoBreak.getValue(true) && breaktimer.passed(delay.getValue(1))) {
                if (picOnly.getValue(true) && !(mc.player.getHeldItem(EnumHand.MAIN_HAND).getItem() == Items.DIAMOND_PICKAXE))
                    return;
                mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                        renderBlock, direction));
                breaktimer.reset();
            }

        }

        try {
            mc.playerController.blockHitDelay = 0;

        } catch (Exception e) {
        }
    }

    private boolean canBreak(BlockPos pos) {
        final IBlockState blockState = mc.world.getBlockState(pos);
        final Block block = blockState.getBlock();

        return block.getBlockHardness(blockState, mc.world, pos) != -1;
    }

    public BlockPos getTarget() {
        return renderBlock;
    }

    public void setTarget(BlockPos pos) {
        renderBlock = pos;
        packetCancel = false;
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.START_DESTROY_BLOCK,
                pos, EnumFacing.DOWN));
        packetCancel = true;
        mc.player.connection.sendPacket(new CPacketPlayerDigging(CPacketPlayerDigging.Action.STOP_DESTROY_BLOCK,
                pos, EnumFacing.DOWN));
        direction = EnumFacing.DOWN;
        lastBlock = pos;
    }
}
